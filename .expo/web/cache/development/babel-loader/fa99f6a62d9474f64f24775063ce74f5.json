{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\nvar CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input) {\n  var output = input;\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n  var bytes = Random.getRandomBytes(input.length);\n\n  for (var i = 0; i < bytes.length; i++) {\n    input[i] = bytes[i];\n  }\n\n  return output;\n}\n\nfunction convertBufferToString(buffer) {\n  var state = [];\n\n  for (var i = 0; i < buffer.byteLength; i += 1) {\n    var index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64) {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandom(size) {\n  var buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\nexport function deriveChallengeAsync(_x) {\n  return _deriveChallengeAsync.apply(this, arguments);\n}\n\nfunction _deriveChallengeAsync() {\n  _deriveChallengeAsync = _asyncToGenerator(function* (code) {\n    invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n    var buffer = yield Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n      encoding: Crypto.CryptoEncoding.BASE64\n    });\n    return convertToUrlSafeString(buffer);\n  });\n  return _deriveChallengeAsync.apply(this, arguments);\n}\n\nexport function buildCodeAsync() {\n  return _buildCodeAsync.apply(this, arguments);\n}\n\nfunction _buildCodeAsync() {\n  _buildCodeAsync = _asyncToGenerator(function* () {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n    var codeVerifier = generateRandom(size);\n    var codeChallenge = yield deriveChallengeAsync(codeVerifier);\n    return {\n      codeVerifier: codeVerifier,\n      codeChallenge: codeChallenge\n    };\n  });\n  return _buildCodeAsync.apply(this, arguments);\n}\n\nexport function generateHexStringAsync(_x2) {\n  return _generateHexStringAsync.apply(this, arguments);\n}\n\nfunction _generateHexStringAsync() {\n  _generateHexStringAsync = _asyncToGenerator(function* (size) {\n    var value = generateRandom(size);\n    var buffer = yield Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n      encoding: Crypto.CryptoEncoding.HEX\n    });\n    return convertToUrlSafeString(buffer);\n  });\n  return _generateHexStringAsync.apply(this, arguments);\n}","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,MAAZ,MAAwB,aAAxB;AACA,OAAO,KAAKC,MAAZ,MAAwB,aAAxB;AACA,OAAOC,SAAP,MAAsB,WAAtB;AAEA,IAAMC,OAAO,GAAG,gEAAhB;;AAEA,SAASC,eAAT,CAAyBC,KAAzB,EAA0C;EACxC,IAAMC,MAAM,GAAGD,KAAf;EAEA,IAAIA,KAAK,CAACE,UAAN,KAAqBF,KAAK,CAACG,MAA/B,EAAuCH,KAAK,GAAG,IAAII,UAAJ,CAAeJ,KAAK,CAACK,MAArB,CAAR;EAEvC,IAAMC,KAAK,GAAGV,MAAM,CAACW,cAAP,CAAsBP,KAAK,CAACG,MAA5B,CAAd;;EAEA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACH,MAA1B,EAAkCK,CAAC,EAAnC;IAAuCR,KAAK,CAACQ,CAAD,CAAL,GAAWF,KAAK,CAACE,CAAD,CAAhB;EAAvC;;EAEA,OAAOP,MAAP;AACD;;AAED,SAASQ,qBAAT,CAA+BJ,MAA/B,EAAiD;EAC/C,IAAMK,KAAK,GAAa,EAAxB;;EACA,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACH,UAA3B,EAAuCM,CAAC,IAAI,CAA5C,EAA+C;IAC7C,IAAMG,KAAK,GAAGN,MAAM,CAACG,CAAD,CAAN,GAAYV,OAAO,CAACK,MAAlC;IACAO,KAAK,CAACE,IAAN,CAAWd,OAAO,CAACa,KAAD,CAAlB;EACD;;EACD,OAAOD,KAAK,CAACG,IAAN,CAAW,EAAX,CAAP;AACD;;AAED,SAASC,sBAAT,CAAgCC,GAAhC,EAA2C;EACzC,OAAOA,GAAG,CAACC,OAAJ,CAAY,KAAZ,EAAmB,GAAnB,EAAwBA,OAAxB,CAAgC,KAAhC,EAAuC,GAAvC,EAA4CA,OAA5C,CAAoD,IAApD,EAA0D,EAA1D,CAAP;AACD;;AAED,OAAM,SAAUC,cAAV,CAAyBC,IAAzB,EAAqC;EACzC,IAAMb,MAAM,GAAG,IAAID,UAAJ,CAAec,IAAf,CAAf;EACAnB,eAAe,CAACM,MAAD,CAAf;EACA,OAAOI,qBAAqB,CAACJ,MAAD,CAA5B;AACD;AAMD,gBAAsBc,oBAAtB;EAAA;AAAA;;;4CAAO,WAAoCC,IAApC,EAAgD;IAErDvB,SAAS,CAACuB,IAAI,CAACjB,MAAL,GAAc,EAAd,IAAoBiB,IAAI,CAACjB,MAAL,GAAc,GAAnC,EAAwC,+BAAxC,CAAT;IAEA,IAAME,MAAM,SAASV,MAAM,CAAC0B,iBAAP,CAAyB1B,MAAM,CAAC2B,qBAAP,CAA6BC,MAAtD,EAA8DH,IAA9D,EAAoE;MACvFI,QAAQ,EAAE7B,MAAM,CAAC8B,cAAP,CAAsBC;IADuD,CAApE,CAArB;IAGA,OAAOZ,sBAAsB,CAACT,MAAD,CAA7B;EACD,C;;;;AAED,gBAAsBsB,cAAtB;EAAA;AAAA;;;sCAAO,aACa;IAAA,IAAlBT,IAAkB,uEAAH,GAAG;IAGlB,IAAMU,YAAY,GAAGX,cAAc,CAACC,IAAD,CAAnC;IACA,IAAMW,aAAa,SAASV,oBAAoB,CAACS,YAAD,CAAhD;IAEA,OAAO;MAAEA,YAAY,EAAZA,YAAF;MAAgBC,aAAa,EAAbA;IAAhB,CAAP;EACD,C;;;;AAKD,gBAAsBC,sBAAtB;EAAA;AAAA;;;8CAAO,WAAsCZ,IAAtC,EAAkD;IACvD,IAAMa,KAAK,GAAGd,cAAc,CAACC,IAAD,CAA5B;IACA,IAAMb,MAAM,SAASV,MAAM,CAAC0B,iBAAP,CAAyB1B,MAAM,CAAC2B,qBAAP,CAA6BC,MAAtD,EAA8DQ,KAA9D,EAAqE;MACxFP,QAAQ,EAAE7B,MAAM,CAAC8B,cAAP,CAAsBO;IADwD,CAArE,CAArB;IAGA,OAAOlB,sBAAsB,CAACT,MAAD,CAA7B;EACD,C","names":["Crypto","Random","invariant","CHARSET","getRandomValues","input","output","byteLength","length","Uint8Array","buffer","bytes","getRandomBytes","i","convertBufferToString","state","index","push","join","convertToUrlSafeString","b64","replace","generateRandom","size","deriveChallengeAsync","code","digestStringAsync","CryptoDigestAlgorithm","SHA256","encoding","CryptoEncoding","BASE64","buildCodeAsync","codeVerifier","codeChallenge","generateHexStringAsync","value","HEX"],"sourceRoot":"","sources":["../src/PKCE.ts"],"sourcesContent":["import * as Crypto from 'expo-crypto';\nimport * as Random from 'expo-random';\nimport invariant from 'invariant';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction getRandomValues(input: Uint8Array): Uint8Array {\n  const output = input;\n  // Get access to the underlying raw bytes\n  if (input.byteLength !== input.length) input = new Uint8Array(input.buffer);\n\n  const bytes = Random.getRandomBytes(input.length);\n\n  for (let i = 0; i < bytes.length; i++) input[i] = bytes[i];\n\n  return output;\n}\n\nfunction convertBufferToString(buffer: Uint8Array): string {\n  const state: string[] = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    const index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction convertToUrlSafeString(b64: string): string {\n  return b64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function generateRandom(size: number): string {\n  const buffer = new Uint8Array(size);\n  getRandomValues(buffer);\n  return convertBufferToString(buffer);\n}\n\n/**\n * Proof key for Code Exchange by OAuth Public Clients (RFC 7636), Section 4.1\n * [Section 4.1](https://tools.ietf.org/html/rfc7636#section-4.1)\n */\nexport async function deriveChallengeAsync(code: string): Promise<string> {\n  // 43 is the minimum, and 128 is the maximum.\n  invariant(code.length > 42 && code.length < 129, 'Invalid code length for PKCE.');\n\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, code, {\n    encoding: Crypto.CryptoEncoding.BASE64,\n  });\n  return convertToUrlSafeString(buffer);\n}\n\nexport async function buildCodeAsync(\n  size: number = 128\n): Promise<{ codeChallenge: string; codeVerifier: string }> {\n  // This method needs to be resolved like all other native methods.\n  const codeVerifier = generateRandom(size);\n  const codeChallenge = await deriveChallengeAsync(codeVerifier);\n\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Digest a random string with hex encoding, useful for creating `nonce`s.\n */\nexport async function generateHexStringAsync(size: number): Promise<string> {\n  const value = generateRandom(size);\n  const buffer = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value, {\n    encoding: Crypto.CryptoEncoding.HEX,\n  });\n  return convertToUrlSafeString(buffer);\n}\n"]},"metadata":{},"sourceType":"module"}